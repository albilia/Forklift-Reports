// ======================================
//  OCR מקומי — Nis Reporter (גרסה משודרגת)
//  • שיפור תמונה
//  • תמיכה במספר תוויות בצילום אחד
//  • חילוץ מק״ט / פק״ע / כמות / משטח
//  • החזרת JSON זהה ל‑Gemini
// ======================================

// פונקציה ראשית — מקבלת base64 ומחזירה { reports: [...] }
async function runLocalOCR(base64Image) {
  try {
    // 1. המרת base64 לתמונה
    const img = await loadImageFromBase64(base64Image);

    // 2. שיפור תמונה (שחור־לבן, קונטרסט, חידוד קל)
    const enhancedCanvas = enhanceImage(img);

    // 3. הרצת OCR על כל התמונה
    const fullText = await runTesseractOnCanvas(enhancedCanvas);

    // 4. ניסיון לפצל לאזורים (תוויות) לפי מרחק שורות
    const labelBlocks = splitToLabelBlocks(fullText);

    // 5. חילוץ נתונים מכל בלוק
    const reports = [];
    labelBlocks.forEach(blockText => {
      const extracted = extractLabelFromText(blockText);
      if (extracted && extracted.makat && extracted.pka && extracted.qty) {
        reports.push(extracted);
      }
    });

    return { reports };

  } catch (err) {
    console.error("OCR ERROR:", err);
    return { reports: [] };
  }
}

// ===============================
//  טעינת תמונה מ‑base64
// ===============================
function loadImageFromBase64(base64) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = base64;
  });
}

// ===============================
//  שיפור תמונה בסיסי
//  • המרה לגווני אפור
//  • הגברת קונטרסט
//  • חידוד קל
// ===============================
function enhanceImage(img) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");

  const maxWidth = 1200;
  const scale = Math.min(1, maxWidth / img.width);

  canvas.width = img.width * scale;
  canvas.height = img.height * scale;

  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // גווני אפור + קונטרסט
  const contrast = 1.3; // 1 = ללא שינוי
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];

    // גווני אפור
    let gray = 0.3 * r + 0.59 * g + 0.11 * b;

    // קונטרסט
    gray = ((gray - 128) * contrast) + 128;
    gray = Math.max(0, Math.min(255, gray));

    data[i] = data[i + 1] = data[i + 2] = gray;
  }

  ctx.putImageData(imageData, 0, 0);

  return canvas;
}

// ===============================
//  הרצת Tesseract על Canvas
// ===============================
async function runTesseractOnCanvas(canvas) {
  const dataUrl = canvas.toDataURL("image/png");

  const result = await Tesseract.recognize(
    dataUrl,
    'heb+eng',
    {
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/-',
    }
  );

  return result.data.text || "";
}

// ===============================
//  פיצול הטקסט לבלוקים (תוויות)
//  לפי רווחים גדולים בין שורות
// ===============================
function splitToLabelBlocks(fullText) {
  const lines = fullText
    .split("\n")
    .map(l => l.trim())
    .filter(l => l.length > 0);

  const blocks = [];
  let currentBlock = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    currentBlock.push(line);

    // אם יש שורה ריקה / מעבר גדול — נניח שזה סוף תווית
    const nextLine = lines[i + 1];
    if (!nextLine || isBlockSeparator(line, nextLine)) {
      blocks.push(currentBlock.join("\n"));
      currentBlock = [];
    }
  }

  if (currentBlock.length) {
    blocks.push(currentBlock.join("\n"));
  }

  return blocks;
}

// הפרדה גסה בין בלוקים — אפשר לשפר לפי הצורך
function isBlockSeparator(line, nextLine) {
  // אם יש שינוי גדול בתבנית (למשל, שורה עם הרבה ספרות ואז שורה עם טקסט)
  const digitsLine = (line.match(/\d/g) || []).length;
  const digitsNext = (nextLine.match(/\d/g) || []).length;

  if (Math.abs(digitsLine - digitsNext) > 6) return true;

  // אם יש מילים כמו "משטח", "סה\"כ", "Total" וכו'
  if (/סה"?כ|משטח|Total|Pallet/i.test(line)) return true;

  return false;
}

// ===============================
//  חילוץ נתונים מבלוק טקסט אחד
// ===============================
function extractLabelFromText(text) {
  const lines = text.split("\n").map(l => l.trim()).filter(l => l.length > 0);

  let makat = "";
  let pka = "";
  let qty = "";
  let palletId = "";

  for (let line of lines) {
    // מק״ט — 9 ספרות
    if (!makat) {
      const makatMatch = line.match(/\b\d{9}\b/);
      if (makatMatch) makat = makatMatch[0];
    }

    // פק״ע — מספר כלשהו, ניקח 3 ספרות אחרונות
    if (!pka) {
      const pkaMatch = line.match(/\b\d{3,}\b/);
      if (pkaMatch) pka = pkaMatch[0].slice(-3);
    }

    // כמות — מספר בין 1 ל־4 ספרות, לא תאריך
    if (!qty) {
      const qtyMatch = line.match(/\b\d{1,4}\b/g);
      if (qtyMatch) {
        const candidate = qtyMatch
          .map(Number)
          .filter(n => n > 0 && n < 5000)[0];
        if (candidate) qty = candidate.toString();
      }
    }

    // מספר משטח — 6–10 ספרות
    if (!palletId) {
      const palletMatch = line.match(/\b\d{6,10}\b/);
      if (palletMatch) palletId = palletMatch[0];
    }
  }

  if (!makat && !pka && !qty) return null;

  return {
    makat,
    pka,
    qty,
    palletId
  };
}